-- Test that index-only scans work correctly with OrioleDB tables
-- This verifies the fix for relallvisible being 0
CREATE SCHEMA index_only_scan;
SET SESSION search_path = 'index_only_scan';
CREATE EXTENSION orioledb;
-- Create a simple table with an index
CREATE TABLE o_test_ios
(
	id int PRIMARY KEY,
	val int,
	data text
) USING orioledb;
-- Create an index on val
CREATE INDEX o_test_ios_val_idx ON o_test_ios(val);
-- Insert some data
INSERT INTO o_test_ios SELECT i, i * 10, 'data_' || i FROM generate_series(1, 1000) i;
-- Run ANALYZE to update statistics
ANALYZE o_test_ios;
-- Check that relallvisible is set correctly in pg_class
-- After our fix, relallvisible should be equal to relpages for OrioleDB tables
SELECT c.relname, c.relpages > 0 as has_pages, c.relallvisible > 0 as has_allvisible
FROM pg_class c
WHERE c.relname = 'o_test_ios';
   relname   | has_pages | has_allvisible 
-------------+-----------+----------------
 o_test_ios  | t         | t
(1 row)

-- Test 1: Simple index-only scan selecting only indexed column
-- This should use Index Only Scan because val is in the index
SET enable_seqscan = off;
SET enable_bitmapscan = off;
EXPLAIN (COSTS OFF) SELECT val FROM o_test_ios WHERE val > 500 ORDER BY val LIMIT 10;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Limit
   ->  Index Only Scan using o_test_ios_val_idx on o_test_ios
         Index Cond: (val > 500)
(3 rows)

SELECT val FROM o_test_ios WHERE val > 500 ORDER BY val LIMIT 10;
 val 
-----
 510
 520
 530
 540
 550
 560
 570
 580
 590
 600
(10 rows)

-- Test 2: Query selecting both indexed and non-indexed columns
-- This should use Index Scan (not index-only) because data is not in index
EXPLAIN (COSTS OFF) SELECT val, data FROM o_test_ios WHERE val > 500 ORDER BY val LIMIT 10;
                       QUERY PLAN                        
---------------------------------------------------------
 Limit
   ->  Index Scan using o_test_ios_val_idx on o_test_ios
         Index Cond: (val > 500)
(3 rows)

SELECT val, data FROM o_test_ios WHERE val > 500 ORDER BY val LIMIT 10;
 val |  data  
-----+--------
 510 | data_51
 520 | data_52
 530 | data_53
 540 | data_54
 550 | data_55
 560 | data_56
 570 | data_57
 580 | data_58
 590 | data_59
 600 | data_60
(10 rows)

-- Test 3: Covering index (index includes all columns needed)
-- Create a covering index
CREATE INDEX o_test_ios_val_id_idx ON o_test_ios(val) INCLUDE (id);
-- This should use Index Only Scan because both val and id are in the covering index
EXPLAIN (COSTS OFF) SELECT val, id FROM o_test_ios WHERE val > 500 ORDER BY val LIMIT 10;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Limit
   ->  Index Only Scan using o_test_ios_val_id_idx on o_test_ios
         Index Cond: (val > 500)
(3 rows)

SELECT val, id FROM o_test_ios WHERE val > 500 ORDER BY val LIMIT 10;
 val | id 
-----+----
 510 | 51
 520 | 52
 530 | 53
 540 | 54
 550 | 55
 560 | 56
 570 | 57
 580 | 58
 590 | 59
 600 | 60
(10 rows)

-- Test 4: Verify behavior with table that has bridged indexes (requires index_bridging option)
-- First, create a table with index bridging enabled
CREATE TABLE o_test_ios_bridged
(
	id int PRIMARY KEY,
	val int,
	data text
) USING orioledb WITH (index_bridging = true);
CREATE INDEX o_test_ios_bridged_val_idx ON o_test_ios_bridged(val);
INSERT INTO o_test_ios_bridged SELECT i, i * 10, 'data_' || i FROM generate_series(1, 1000) i;
-- Run VACUUM to trigger statistics update for tables with bridged indexes
VACUUM o_test_ios_bridged;
-- Check that relallvisible is set correctly after VACUUM
SELECT c.relname, c.relpages > 0 as has_pages, c.relallvisible > 0 as has_allvisible,
       c.relallvisible = c.relpages as allvisible_equals_pages
FROM pg_class c
WHERE c.relname = 'o_test_ios_bridged';
        relname        | has_pages | has_allvisible | allvisible_equals_pages 
-----------------------+-----------+----------------+-------------------------
 o_test_ios_bridged    | t         | t              | t
(1 row)

-- The query should use Index Only Scan
EXPLAIN (COSTS OFF) SELECT val FROM o_test_ios_bridged WHERE val > 500 ORDER BY val LIMIT 10;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Limit
   ->  Index Only Scan using o_test_ios_bridged_val_idx on o_test_ios_bridged
         Index Cond: (val > 500)
(3 rows)

-- Test 5: Compare with regular heap table to demonstrate the difference
CREATE TABLE heap_test_ios
(
	id int PRIMARY KEY,
	val int,
	data text
);
CREATE INDEX heap_test_ios_val_idx ON heap_test_ios(val);
INSERT INTO heap_test_ios SELECT i, i * 10, 'data_' || i FROM generate_series(1, 1000) i;
ANALYZE heap_test_ios;
-- Check relallvisible for heap table (should be 0 before VACUUM)
SELECT c.relname, c.relpages > 0 as has_pages, c.relallvisible
FROM pg_class c
WHERE c.relname = 'heap_test_ios';
    relname     | has_pages | relallvisible 
----------------+-----------+---------------
 heap_test_ios  | t         |             0
(1 row)

-- Even though both tables have similar data, the planner behavior differs
-- OrioleDB should favor index-only scans more readily
EXPLAIN (COSTS OFF) SELECT val FROM heap_test_ios WHERE val > 500 ORDER BY val LIMIT 10;
                          QUERY PLAN                           
---------------------------------------------------------------
 Limit
   ->  Index Scan using heap_test_ios_val_idx on heap_test_ios
         Index Cond: (val > 500)
(3 rows)

-- Clean up
DROP SCHEMA index_only_scan CASCADE;
NOTICE:  drop cascades to 4 other objects
DETAIL:  drop cascades to table o_test_ios
drop cascades to sequence o_test_ios_id_seq
drop cascades to table o_test_ios_bridged
drop cascades to table heap_test_ios
